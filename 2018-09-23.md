## 0x01 TripleDoggy

上交GoSSIP的一个漏洞检测[项目](https://github.com/GoSSIP-SJTU/TripleDoggy)

主要检测：空指针解引用、双重释放、整形溢出

#### 1.NewDereferenceChecker

查了2017年的一些CVE => *绝大部分的空指针解引用bug来源于未对内存分配的返回作校验*

相关算法：

    1. 识别所有的内存分配函数。

    2. 获得所有的内存分配函数与new操作符的返回值并加入集合A。

    3. 在地址被访问或者被写入时插入hook函数。

    4. 检查看被访问的地址是否是A中任何一个地址的子地址，如是则对该地址进行约束求解，如果为0则报告错误。

#### 2.DoubleFreeChecker

相关算法：

使用的启发式的内存分配函数的识别方法识别出内存分配函数和释放函数。定义两个集合，分别为已经分配未释放的内存集合A，已释放的内存集合B。通过符号执行，分析遇到内存分配函数时将该内存记录到A中，分析遇到释放函数时，将该块内存记录到B集合中并且删除A中对应的内存（如果存在的话），再次遇到对该块内存的释放操作时报告漏洞。在符号dead时检测是否存在A集合中的元素，存在则报告内存泄漏。在访问内存数据 时，检测所在内存是否在B集合中，在则报告UAF漏洞。

#### 3.IntegerOverflowChecker

在top frame函数的开始处，将全局变量，输入参数标记为污点源，并在接下来的分析中，将标准输入函数的输入数据和未被定义的函数的返回值，指针形参数标记为污点源。
在进行算术运算(目前定义为加法，减法，乘法)时，检查左值或者右值是否被污染，如果其中一个值被污染，则根据运算的值的类型检查算术运算结果是否溢出，如果溢出则将运算结果的符号值及产生溢出的条件记录下来。
符号执行行至数组索引访问操作或者内存分配函数时，检测参数(数组索引 ，内存分配函数的整形参数)是否包含在记录中，如果存在，则将该溢出条件取出，再次检查该条件是否满足，如果满足则报告溢出漏洞。

## rust

学习了[第三章(语句表达式)](https://github.com/D4rkD0g/Rust-Learning/tree/master/Dive_into_Rust/Ch3语句表达式)、[第四章(函数)](https://github.com/D4rkD0g/Rust-Learning/tree/master/Dive_into_Rust/Ch4函数)，书上有些代码错误，咳咳～这个作者还是要认真的跑跑代码呀～～


